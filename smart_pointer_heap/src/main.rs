use crate::List::{Cons, Nil};

fn main() {
    // 스마트포인터의 한 종류인 box는 stack이 아니라 heap에 데이터를 저장
    // box가 주로 사용되는 예시
    // - 컴파일 타임에 크기를 알 수 없는 타입이 있는데 정확한 크기를 요구하는 컨텍스트 내에서 그 타입의 값을 사용하고 싶을 때
    // - 커다란 데이터를 가지고 소유권을 옮기고 싶지만 데이터가 복사되지 않을 것을 보장하고 싶을 때
    // - 값을 소유하고 구체화된 타입보다는 특정 트레이트를 구현한 타입이라는 점만 신경쓰고 싶을 때
   let b = Box::new(5); 
   println!("b = {}", b); //< 스택에 있는 것처럼 접근 가능

    // 재귀적 타입은 자신 안에 동일한 타입의 다른 값을 담을 수 있는 타입
    // Box 안에 Box 타입을 재귀적으로 이론상 무한히 넣을 수 있음
    // 러스트는 컴파일 타임에 일반적으로 어떤 타입이 얼만큼의 공간을 차지하는지 알아야해 재귀적 타입은 문제를 일으킨다.
    // 하지만 박스는 알려진 크기(스택의 변수의 크기를 말하며 힙에 저장된 데이터의 크기는 모름)를 갖고 있고, 재귀적 타입을 가능하게 할 수 있음

   // 콘스 리스트(cons list)는 함수형 프로그램 언어에서 흔히 사용되는 데이터 타입
   // Lisp 프로그래밍 언어류로부터 유래된 중첩된 쌍 형태의 데이터 구조로, 링크드 리스트의 Lisp 버전
   // cons는 Lisp의 생성함수(construct function의 줄임말)로부터 유래
   // (1, (2, (3, Nil)))
   // Nil은 재귀의 기본 케이스를 의미하는 표준 이름으로, null 또는 nil 과는 다른 개념임
   
    // 콘스 리스트는 흔히 사용되는 구조는 아니며, 일반적으로 Vec<T>가 보다 나은 선택

    // 아래 호출은 Cons 안에 Cons가 얼마나 많이 들어있을지 알지 못함
    // let list = Cons(1, Cons(2, Cons(3, Nil)));

    // 아래 호출은 Box<T>를 이용해 포인터를 저장하기 때문에 크기를 알 수 있음
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}

enum List {
    // Cons(i32, List),
    Cons(i32, Box<List>),
    Nil,
}