//! 여기서의 대부분의 고급 기능은 거의 불필요

/// 연관 타입
/// 타입 자리 표시자와 트레이트를 연결하여,
/// 트레이트 메서드 정의 시,
/// 자리표시자 타입을 시그니처에서 사용할 수 있도록 함
/// 
/// 트레이트의 구현자는 
/// 자리 표시자 타입 대신 사용할 구체적 타입을 지정
/// 
/// -> 트레이트가 구현될 때까지 해당 타입이 무엇인지 정확히 알 필요 없음
/// -> 임의 타입 사용하는 트레이트 정의 가능
/// 
/// ex) 표준 라이브러리의 `Iterator` 트레이트
/// - `Iterator` 트레이트의 구현자는 `Item`의 구체적 타입을 지정
/// - `next` 메서드는 구체적 타입의 값을 갖고 있는 `Option`을 반환
/// 
/// 연관 타입 자체는 제네릭과 비슷한 개념처럼 보일 수 있으나,
/// 제네릭은 처리 가능한 타입을 지정하지 않으면서 함수를 정의할 수 있음
/// 제네릭은 사용하는 쪽에서 타입을 지정해줘야 함
/// 연관 타입은 트레이트 구현 시 타입을 결정함
/// 
/// 제네릭은 다양한 타입을 지원할 수 있지만, 타입인자가 많아질 수 있음
/// 연관 타입은 특정 타입을 고정하지만 코드가 단순해지고 명확해짐
pub trait Iterator {
    // 연관타입 Item
    // Item은 자리표시자
    type Item;

    // `next` 메서드 정의는 `Option<Self::Item>` 타입의 값을 반환
    fn next(&mut self) -> Option<Self::Item>;
}

struct Counter;

impl Iterator for Counter {
    // 사용할 타입을 외부에서 인자처럼(제네릭) 받지 않고
    // 직접 트레이트를 구현(impl)할 때 타입을 지정
    type Item = u32; // 연관 타입을 u32로 구현

    fn next(&mut self) -> Option<Self::Item> {
        Some(0)
    }
}

fn main() {
    println!("Hello, world!");
}
