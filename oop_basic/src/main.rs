//! 러스트는 객체 지향 정의에 따라, 객체 지향적
//!
//! 하지만, 상속은 제공하지 않음
//! 매크로를 사용하지 않고는 부모 구조체의 필드와 메서드 구현을 상속받는 구조체를 정의할 수 없음
//! 상속이 익숙하다면 다른 솔루션들(트레이트로 공통 동작 정의 등)을 이용할 수 있음
//! 상속의 이유는 (1)코드 재사용과 (2)타입 시스템(다형성) 때문임
//! 그럼에도 상속은 필요 이상으로 많은 코드를 공유할 수 있는 위험이 있기 때문이며, 이는 오히려 설계의 유연성을 저하함 (특히 단일 상속)
//! 따라서, 러스트는 상속 대신 트레이트 객체를 사용하는 다른 접근법 선택

fn main() {
    println!("Hello, world!");
}
