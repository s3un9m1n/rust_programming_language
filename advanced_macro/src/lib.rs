/// 간소화된 `vec!` 매크로의 정의
/// - 실제 `vec!`에는 정확한 메모리 할당을 위한 코드가 포함되어 있음
/// - 이외에도 최적화가 포함되어있음
///
/// - `#[macro_export]` 어노테이션은 매크로가 정의된 크레이트를 스코프로 가져올 때마다 사용할 수 있어야 함을 의미
///   - 즉, 이 어노테이션이 없으면 매크로를 스코프로 가져올 수 없음
/// - `macro_rules!`와 정의하려는 매크로의 이름을 '느낌표 없이' 정의
/// - `vec!` 본문의 구조는 `match` 표현식의 구조와 유사
/// - 아래에는 `( $( $x:expr ),* )` 패턴 뒤에 `=>`이 붙고, 패턴과 연관된 코드 블록 갈래가 존재함
///   - 아래에는 패턴이 유일하며, 다른 패턴은 에러가 발생
/// - 단, 매크로의 패턴은 값이 아닌 **러스트 코드 구조**에 대해 매칭
/// - 매크로 패턴
///   - 괄호 한 쌍'()'을 사용해 전체 패턴을 둘러쌈
///   - 달러 기호'$'를 이용해 패턴에 사용될 러스트 코드를 담는 변수를 선언 (매크로 변수임을 나타냄)
///   - 달러 기호 뒤에 괄호 한 쌍'()'을 사용해 패턴 값을 입력
///   - `$()` 안에 있는 `$x:expr`의 경우, 모든 러스트 표현식(`expr`)과 매칭되며, 표현식에 `$x`라는 이름을 부여
///   - `$()` 뒤에 나오는 쉼표는 `$()` 안의 코드와 매칭되는 코드 뒤 쉼표 구분자가 나올 수 있음을 말함
///   - 쉼표 뒤에 나오는 `*`는 `*` 앞에 오는 모든 것과 매칭되는 것이 0개 이상 올 수 있음을 표현
///   - 즉, `vec![1, 2, 3];` 호출 시, `$x` 패턴은 `1`, `2`, `3` 세 표현식으로 세 번 매칭
/// - 패턴 매칭 결과
///   - 연관 코드 내에 패턴의 `$()`와 매칭되는 부분에 대해서, `temp_vec.push()`가 생성됨
///   - 따라서, `$x`는 각각 매칭된 표현식으로 대체됨
///   - 매크로는 `vec![1, 2, 3];` 호출 시, 다음의 대체 코드를 생성함
///   - ``` rust
///     let mut temp_vec = Vec::new();
///     temp_vec.push(1);
///     temp_vec.push(2);
///     temp_vec.push(3);
///     temp_vec
///
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}