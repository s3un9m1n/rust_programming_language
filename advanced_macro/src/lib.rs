/// 간소화된 `vec!` 매크로의 정의
/// - 실제 `vec!`에는 정확한 메모리 할당을 위한 코드가 포함되어 있음
/// - 이외에도 최적화가 포함되어있음
///
/// - `#[macro_export]` 어노테이션은 매크로가 정의된 크레이트를 스코프로 가져올 때마다 사용할 수 있어야 함을 의미
///   - 즉, 이 어노테이션이 없으면 매크로를 스코프로 가져올 수 없음
/// - `macro_rules!`와 정의하려는 매크로의 이름을 '느낌표 없이' 정의
/// - `vec!` 본문의 구조는 `match` 표현식의 구조와 유사
/// - 아래에는 `( $( $x:expr ),* )` 패턴 뒤에 `=>`이 붙고, 패턴과 연관된 코드 블록 갈래가 존재함
///   - 아래에는 패턴이 유일하며, 다른 패턴은 에러가 발생
/// - 단, 매크로의 패턴은 값이 아닌 **러스트 코드 구조**에 대해 매칭
/// - 매크로 패턴
///   - 괄호 한 쌍'()'을 사용해 전체 패턴을 둘러쌈
///   - 달러 기호'$'를 이용해 패턴에 사용될 러스트 코드를 담는 변수를 선언 (매크로 변수임을 나타냄)
///   - 달러 기호 뒤에 괄호 한 쌍'()'을 사용해 패턴 값을 입력
///   - `$()` 안에 있는 `$x:expr`의 경우, 모든 러스트 표현식(`expr`)과 매칭되며, 표현식에 `$x`라는 이름을 부여
///   - `$()` 뒤에 나오는 쉼표는 `$()` 안의 코드와 매칭되는 코드 뒤 쉼표 구분자가 나올 수 있음을 말함
///   - 쉼표 뒤에 나오는 `*`는 `*` 앞에 오는 모든 것과 매칭되는 것이 0개 이상 올 수 있음을 표현
///   - 즉, `vec![1, 2, 3];` 호출 시, `$x` 패턴은 `1`, `2`, `3` 세 표현식으로 세 번 매칭
/// - 패턴 매칭 결과
///   - 연관 코드 내에 패턴의 `$()`와 매칭되는 부분에 대해서, `temp_vec.push()`가 생성됨
///   - 따라서, `$x`는 각각 매칭된 표현식으로 대체됨
///   - 매크로는 `vec![1, 2, 3];` 호출 시, 다음의 대체 코드를 생성함
///   - ``` rust
///     let mut temp_vec = Vec::new();
///     temp_vec.push(1);
///     temp_vec.push(2);
///     temp_vec.push(3);
///     temp_vec
///
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}

/// 절차적 매크로
/// - 선언적 매크로처럼 패턴에 매칭해서 다른 코드로 대체하는 것이 아니라, 어떤 코드를 입력받아 해당 코드에 대한 작업 수행 후 어던 코드를 출력 생성
/// - 3가지 종류
///   (1) 커스텀 파생(custon derive)
///   (2) 속성형(attribute-like)
///   (3) 함수형(function-like)
/// - 특별한 형식을 가즌 자신만의 크레이트에 정의 필요

// - `some_attribute`는 자리표시자 (예시이기 때문에 실제로는 존재하지 않는 이름 -> 빌드 불가)
// `TokenStream`을 입력받아서 `TokenStream`을 출력으로 생성
// `TokenStream`타입은 러스트의 `proc_macro` 크레이트에 정의되어 있으며, 토큰의 시퀀스를 나타냄
// - 핵심: 매크로가 작동하는 소스코드가 입력을 `TokenStream`을 구성하고, 매크로가 생성하는 코드가 출력 `TokenStream`
use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -> TokenStream {
}
