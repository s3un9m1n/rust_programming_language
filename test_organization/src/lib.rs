pub fn add(left: u64, right: u64) -> u64 {
    left + right
}

pub fn add_two(a: i32) -> i32 {
    a + 2
}

// 비공개 함수
fn internal_adder(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)] //< cargo test 명령어 실행 시 컴파일 및 실행될 것임을 전달함
// 일반적인 라이브러리 빌드 시에는 테스트 코드는 제외되어 컴파일 시간도 짧아지고 결과물 크기도 줄어듦
// 통합 테스트는 별도 디렉터리에 위치하기 때문에 #[cfg(test)] 어노테이션 불필요
mod tests {
    use super::*;

    // cargo test 명령어 실행 시 테스트 코드를 컴파일하는데,
    // #[test] 어노테이션된 함수뿐만 아니라 모듈 내 도우미 함수도 포함해 빌드됨
    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }

    // 비공개 함수도 테스트 가능
    // 다른 언어의 경우 비공개 함수를 테스트하기 어렵거나 불가능하게 하여 비공개 함수에 대한 테스트 논쟁이 있음 (개발자 철학에 맞춰서 테스트 가능)
    // 비공개 함수이더라도 러스트에서는 그저 러스트 코드이며, tests 모듈도 그저 또 다른 모듈일 뿐,
    // 경로를 이용해 조상 모듈에 있는 아이템 사용 가능
    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}

// 유닛 테스트
// - 코드들을 분리하여 제대로 작동하지 않는 코드가 어느 부분인지 빠르게 파악하기 위함
// - src 디렉터리 내의 각 파일에 테스트 대상이 될 코드와 함께 작성함
// - 각 파일에 tests 모듈을 만들고 cfg(test)를 어노테이션하는 관례