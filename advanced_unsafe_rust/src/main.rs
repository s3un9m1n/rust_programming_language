//! 지금까지는 컴파일 타임에 메모리 안전 보장이 이뤄졌음
//! 러스트에서는 메모리 안전 보장을 하지 않을 수도 있음 (unsafe Rust)
//!
//! 러스트 컴파일러는
//! 일부 유효하지 않은 프로그램을 허용하는 것보다
//! 일부 유효한 프로그램을 거부하는 것이 더 낫다는 입장
//!
//! 러스트 컴파일러는 확신이 없다면 거부할 것임
//! unsafe Rust는 순전히 사용자의 책임하에 사용되는 것
//!
//! - `unsafe` 키워드로 unsafe Rust 전환 가능
//! - 다음과 같은 기능 포함
//!     - 원시 포인터(raw pointer) 역참조
//!     - 안전하지 않은 함수 또는 메서드 호출
//!     - 가변 정적 변수에 접근 및 수정
//!     - 안전하지 않은 트레이트 구현
//!     - `union`의 필드 접근
//! - 따라서, `unsafe`일지라도 어느정도의 안전성 확보 가능
//! - 또한, `unsafe`일지라도 내부가 반드시 위험하거나 메모리 안전에 문제가 있는 것도 아님
//! - 제공 기능과 관련된 위험은 항상 `unsafe` 블록 안에 있게 됨
//! - `unsafe` 블록은 최대한 작게 유지해야 함
//! - 안전하지 않은 코드는 최대한 분리 필요하며, 안전하지 않은 코드를 안전한 추상화 안에 넣고 안전한 API를 제공하는 것이 바람직
//! - 안전하지 않은 코드를 안전 추상화로 감싸면 `unsafe` 코드가 구현된 기능을 사용하려는 모든 곳에 `unsafe` 라고 쓰는 것을 방지할 수 있음
//!     (추상화 사용 시 안전함)
fn main() {
    // 1. 원시 포인터(raw pointer) 역참조
    // - 원시 포인터: 참조와 유사하며, 불변과 가변이 각각 `*const T`와 `*mut T`로 작성됨
    // - '*': 역참조 연산자가 아닌 타입 이름의 일부
}
